<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>Duck-typing and XForms</title>
  <meta name="description" content="In a recent code review on the Ubiquity XForms project, the question of whether to test for anelement by name or properties came up. In this post we look at ...">

  <link rel="stylesheet" href="/css/main.css">
  <link rel="canonical" href="http://markbirbeck.com/xforms/mark%20birbeck/role/2009/02/03/duck-typing-and-xforms.html">
  <link rel="alternate" type="application/rss+xml" title="Mark Birbeck's Blog" href="http://markbirbeck.com/feed.xml" />
</head>


  <body>

    <header class="site-header">

  <div class="wrapper">

    <a class="site-title" href="/">Mark Birbeck's Blog</a>

    <nav class="site-nav">
      <a href="#" class="menu-icon">
        <svg viewBox="0 0 18 15">
          <path fill="#424242" d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.031C17.335,0,18,0.665,18,1.484L18,1.484z"/>
          <path fill="#424242" d="M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0c0-0.82,0.665-1.484,1.484-1.484 h15.031C17.335,6.031,18,6.696,18,7.516L18,7.516z"/>
          <path fill="#424242" d="M18,13.516C18,14.335,17.335,15,16.516,15H1.484C0.665,15,0,14.335,0,13.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.031C17.335,12.031,18,12.696,18,13.516L18,13.516z"/>
        </svg>
      </a>

      <div class="trigger">
        
          
          <a class="page-link" href="/about/">About</a>
          
        
          
        
          
        
          
        
      </div>
    </nav>

  </div>

</header>


    <div class="page-content">
      <div class="wrapper">
        <div class="post">

  <header class="post-header">
    <h1 class="post-title">Duck-typing and XForms</h1>
    <p class="post-meta">Feb 3, 2009</p>
  </header>

  <article class="post-content">
    <p>In a recent code review on the <a href="http://ubiquity-
xforms.googlecode.com/">Ubiquity XForms</a> project, the question of whether to test for an
element by name or properties came up. In this post we look at the benefits
that can be had from using <em>duck-typing</em> as a way to manage objects’
functionality, rather than the more usual hierarchical solutions.</p>

<!-- more -->

<h2 id="oo-hierarchies">OO hierarchies</h2>

<p>The usual sort of example given when looking at and explaining object
hierarchies, is to say that we have a class called <code>Vehicle</code>, from which we
can derive a class <code>Car</code> and <code>Bicycle</code>.</p>

<p>What I’ve always hated about this kind of ordering is that you actually spend
more time discussing where to put properties than actually writing code. For
example, is a motorbike a type of bicycle, that just happens to have an
engine? Is a van a small lorry?</p>

<p>And more to the point, who cares?</p>

<p>Well, the Department for Transport might care, but they also might change
their definitions based on all sorts of criteria, such as lead in petrol,
engine size, number of wheel axles, and so on. In fact, if you were in charge
of building the DfT a system, then you would certainly be asking for trouble
if you encoded their definitions of vehicles directly into the object
hierarchy of your application.</p>

<h2 id="duck-typing">Duck-typing</h2>

<p>Many programmers will be familiar with the idea of <a href="http://en.wikipedia.org/wiki/Duck_typing">duck-
typing</a>, which is a different way to
look at objects in object-oriented systems.</p>

<p>The name comes from the idea that ‘if something walks like a duck, and quacks
like a duck, then it’s a duck’. So if an object has a property of <code>wheels</code> and
perhaps <code>engine</code>, then it’s a <code>Vehicle</code>.</p>

<p>This can make for very efficient systems, because the ‘type’ of an object is
no longer tied directly to its class in the source code, which as we know is
very difficult to change, but is instead something that can be determined at
run time. More than that, the ‘type’ of an object is worked out at the point
of need, allowing objects to take on many personae, in a way that multiple
inheritance is simply not able to cope with. For example, our <code>Vehicle</code>
becomes an object of type ‘printable’, merely by the presence of a <code>print()</code>
method.</p>

<h2 id="xforms">XForms</h2>

<p>The XForms language wasn’t designed with duck-typing in mind, but as I’ll
illustrate, duck-typing is an incredibly powerful way to implement a flexible
and extensible XForms processor.</p>

<p>We’ll use the XForms <code>hint</code> element to illustrate.</p>

<h3 id="the-hint-element">The hint element</h3>

<p>The XForms hint element contains text or mark-up that will be displayed to a
user when the hint event is fired, which is usually related to the <code>mouseover</code>
event in browser-based processors. When the event occurs, the relevant text or
mark-up is displayed to the user, and when some other event occurs (such as a
<code>mouseout</code>, a timer expiring, etc.) then the hint is hidden.</p>

<p>The actual text to be displayed can be obtained inline from the element, or
via the usual binding techniques, such as using <code>@ref</code>, <code>@value</code> or <code>@bind</code>.</p>

<p>So we have two aspects to a hint; the first concerns its behaviour – and you
could say this is the key to its <em>hintyness</em> – whilst the second aspect
concerns what should be displayed.</p>

<p>The second aspect – the ‘what to display part’ – is actually common to a
number of elements in XForms, such as <code>xf:output</code>, <code>xf:help</code>, <code>xf:alert</code>, and
so on; they can all either display inline text, or text that is obtained from
the instance data.</p>

<p>In the UXF library, the two <code>aspects</code> of a hint are kept separate, on two
separate objects, and these two objects are dynamically added to a hint object
at run time. This is different to a traditional object model where we would
have a hint object that inherits from the ‘what to display object’, creating a
rigid hierarchy; in our model we have a <em>hintyness</em> object that handles the
‘show and hide’ part, and we have a ‘what to display object’ that manages the
data, and we bring the two together when we encounter the XForms hint element.</p>

<p>The beauty of this is its flexibility; we can ‘attach’ our ‘what to display’
object to anything, independent of whether it’s a hint, and the object will
manage the processing of <code>@ref</code> and <code>@value</code>. And we can also attach our
‘hinty’ object to anything to make it behave like a hint, independent of the
‘what to display’ behaviour; SVG circles or HTML5 video objects could all be
given hint behaviour, simply by attaching the <em>hintyness</em> object.</p>

<h3 id="the-role-attribute">The role attribute</h3>

<p>The obvious way to indicate in mark-up that we have an object of a certain
type is to use the element directly. For example, in XForms we could write:</p>

<pre><code>&lt;xf:hint&gt;Please enter your name&lt;/xf:hint&gt;  
</code></pre>

<p>or:</p>

<pre><code>&lt;xf:hint ref="msg" /&gt;  
</code></pre>

<p>But the <a href="/standard/xhtml-role"><code>role</code> attribute</a> opens up the possibility of
assigning functionality to non-XForms elements, for example:</p>

<pre><code>&lt;span role="xf:hint"&gt;Please enter your name&lt;/span&gt;  
</code></pre>

<p>Now we get our duck-typing in reverse; ‘if an element says that it wants to be
a duck, give it the <em>waddle</em> and <em>quack</em> methods’.</p>

<h2 id="ubiquity-xforms">Ubiquity XForms</h2>

<p>The Ubiquity library makes use of this dynamic binding technique to create
flexible run-time objects, through the use of a <em>decoration</em> mechanism; a set
of rules have been created that indicate which objects to attach to which
elements, and when a document loads, the functionality is ‘wired in’ to each
element, as expressed in the rules. Adding new elements is easy, since it just
requires adding more rules.</p>

<p>But the code review I mentioned earlier related to the other side of this, the
original duck-typing question. We had a piece of code that needed to toggle a
<code>xf:case</code>, and the natural inclination was to check the name of the element,
to ensure we really had a <em>casey</em> element, i.e., one that could be toggled.</p>

<p>Yet to be an element that could be toggled only requires the presence of the
<code>toggle()</code> method; just as anything that quacks is a duck, so anything that
can be toggled is a case.</p>

<p>So instead of checking the element name:</p>

<pre><code>if (NamespaceManager.compareFullName(oCase, "case", "http://www.w3.org/2002/xforms")) {  
  ...  
}  
</code></pre>

<p>our code now checks for the method:</p>

<pre><code>if (oCase &amp;&amp; typeof oCase['toggle'] === 'function') {  
  oCase.toggle();  
}  
</code></pre>

<h2 id="loosely-coupled-objects">Loosely-coupled Objects</h2>

<p>Another key design goal of the Ubiquity suite is that the objects that make up
the system are ‘loosely-coupled’. This means that they can change
independently of each other, and as a consequence, improvements in one area
should immediately benefit other areas.</p>

<p>In this case, imagine that a rule is added to the decorator module such that
the presence of <code>@role="xf:case"</code> on a <code>div</code> causes all <em>caseyness</em>
functionality to be attached. With the duck-typing way of testing whether to
toggle, the following mark-up will just immediately start working:</p>

<pre><code>&lt;xf:switch&gt;  
  &lt;xf:case id="error"&gt;...&lt;/xf:case&gt;  
  
  &lt;div id="ok" role="xf:case"&gt;...&lt;/div&gt;  
&lt;/xf:switch&gt;  
</code></pre>

<p>With the prior method – checking the name of the element – it would not have
worked until we had added code to check for the presence of <code>@role</code>. In other
words, we would have been in exactly the same situation as a normal object
hierarchy application, adding special code to test for specific things.</p>

<h2 id="conclusion">Conclusion</h2>

<p>Whilst duck-typing can be confusing if used in every aspect of an application,
it can work well when its boundaries are clear. In Ubiquity XForms and
<a href="http://ubiquity-smil.googlecode.com/">Ubiquity SMIL</a>, elements can acquire
rich combinations of functionality based on their position in a document, the
element name, the presence of other attributes, and so on. In this situation,
duck-typing is a natural fit, and keeps the architecture open.</p>


  </article>

</div>

      </div>
    </div>

    <footer class="site-footer">

  <div class="wrapper">

    <h2 class="footer-heading">Mark Birbeck's Blog</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col  footer-col-1">
        <ul class="contact-list">
          <li>Mark Birbeck's Blog</li>
          <li><a href="mailto:mark.birbeck@gmail.com">mark.birbeck@gmail.com</a></li>
        </ul>
      </div>

      <div class="footer-col  footer-col-2">
        <ul class="social-media-list">
          
          <li>
            <a href="https://github.com/markbirbeck">
              <span class="icon  icon--github">
                <svg viewBox="0 0 16 16">
                  <path fill="#828282" d="M7.999,0.431c-4.285,0-7.76,3.474-7.76,7.761 c0,3.428,2.223,6.337,5.307,7.363c0.388,0.071,0.53-0.168,0.53-0.374c0-0.184-0.007-0.672-0.01-1.32 c-2.159,0.469-2.614-1.04-2.614-1.04c-0.353-0.896-0.862-1.135-0.862-1.135c-0.705-0.481,0.053-0.472,0.053-0.472 c0.779,0.055,1.189,0.8,1.189,0.8c0.692,1.186,1.816,0.843,2.258,0.645c0.071-0.502,0.271-0.843,0.493-1.037 C4.86,11.425,3.049,10.76,3.049,7.786c0-0.847,0.302-1.54,0.799-2.082C3.768,5.507,3.501,4.718,3.924,3.65 c0,0,0.652-0.209,2.134,0.796C6.677,4.273,7.34,4.187,8,4.184c0.659,0.003,1.323,0.089,1.943,0.261 c1.482-1.004,2.132-0.796,2.132-0.796c0.423,1.068,0.157,1.857,0.077,2.054c0.497,0.542,0.798,1.235,0.798,2.082 c0,2.981-1.814,3.637-3.543,3.829c0.279,0.24,0.527,0.713,0.527,1.437c0,1.037-0.01,1.874-0.01,2.129 c0,0.208,0.14,0.449,0.534,0.373c3.081-1.028,5.302-3.935,5.302-7.362C15.76,3.906,12.285,0.431,7.999,0.431z"/>
                </svg>
              </span>

              <span class="username">markbirbeck</span>
            </a>
          </li>
          

          
          <li>
            <a href="https://twitter.com/markbirbeck">
              <span class="icon  icon--twitter">
                <svg viewBox="0 0 16 16">
                  <path fill="#828282" d="M15.969,3.058c-0.586,0.26-1.217,0.436-1.878,0.515c0.675-0.405,1.194-1.045,1.438-1.809
                  c-0.632,0.375-1.332,0.647-2.076,0.793c-0.596-0.636-1.446-1.033-2.387-1.033c-1.806,0-3.27,1.464-3.27,3.27 c0,0.256,0.029,0.506,0.085,0.745C5.163,5.404,2.753,4.102,1.14,2.124C0.859,2.607,0.698,3.168,0.698,3.767 c0,1.134,0.577,2.135,1.455,2.722C1.616,6.472,1.112,6.325,0.671,6.08c0,0.014,0,0.027,0,0.041c0,1.584,1.127,2.906,2.623,3.206 C3.02,9.402,2.731,9.442,2.433,9.442c-0.211,0-0.416-0.021-0.615-0.059c0.416,1.299,1.624,2.245,3.055,2.271 c-1.119,0.877-2.529,1.4-4.061,1.4c-0.264,0-0.524-0.015-0.78-0.046c1.447,0.928,3.166,1.469,5.013,1.469 c6.015,0,9.304-4.983,9.304-9.304c0-0.142-0.003-0.283-0.009-0.423C14.976,4.29,15.531,3.714,15.969,3.058z"/>
                </svg>
              </span>

              <span class="username">markbirbeck</span>
            </a>
          </li>
          
        </ul>
      </div>

      <div class="footer-col  footer-col-3">
        <p class="text">From agile and lean to big data and the semantic web.
</p>
      </div>
    </div>

  </div>

</footer>


  </body>

</html>
